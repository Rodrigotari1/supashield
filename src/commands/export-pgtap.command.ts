import { Command } from 'commander';
import { writeFile } from 'fs/promises';
import { loadPolicyConfigurationFromFile } from '../shared/config.js';
import type { PolicyConfig, DatabaseOperation } from '../shared/types.js';
import { createLogger } from '../shared/logger.js';

export const exportPgtapCommand = new Command('export-pgtap')
  .description('Export policy tests to pgTap format')
  .option('-o, --output <file>', 'Output file path', 'tests/rls_tests.sql')
  .option('--verbose', 'Enable verbose logging')
  .action(async (options) => {
    const logger = createLogger(options.verbose);

    try {
      logger.start('Loading policy configuration...');
      const config = await loadPolicyConfigurationFromFile();
      logger.succeed('Configuration loaded');

      logger.start('Generating pgTap tests...');
      const pgtapSql = generatePgTapTests(config);
      logger.succeed('Tests generated');

      logger.start(`Writing to ${options.output}...`);
      await writeFile(options.output, pgtapSql, 'utf-8');
      logger.succeed(`pgTap tests exported to ${options.output}`);
      
      logger.info('\nTo run these tests:');
      logger.info(`  psql -d your_database -f ${options.output}`);

    } catch (error) {
      logger.error('Failed to export pgTap tests', error);
      process.exit(1);
    }
  });

function generatePgTapTests(config: PolicyConfig): string {
  const lines: string[] = [];

  // Header with disclaimer
  lines.push('-- ======================================');
  lines.push('-- Generated by SupaShield');
  lines.push('-- pgTap tests for RLS policies');
  lines.push('-- ======================================');
  lines.push('--');
  lines.push('-- IMPORTANT: This is a generated starting point.');
  lines.push('-- You may need to customize:');
  lines.push('--   - Role names (anon/authenticated/service_role)');
  lines.push('--   - JWT claim injection for your setup');
  lines.push('--   - INSERT/UPDATE/DELETE column names and values');
  lines.push('--   - WHERE clauses for UPDATE/DELETE tests');
  lines.push('--');
  lines.push('-- How tests work:');
  lines.push('--   - DENY tests use throws_ok() to verify permission errors');
  lines.push('--   - ALLOW tests use PREPARE + lives_ok() to verify permissions');
  lines.push('--   - All tests run in a transaction that rolls back');
  lines.push('--   - No data is actually modified');
  lines.push('--');
  lines.push('-- Prerequisites:');
  lines.push('--   1. Install pgTap: https://pgtap.org/');
  lines.push('--   2. CREATE EXTENSION pgtap;');
  lines.push('--');
  lines.push('-- Run with: psql -d your_database -f this_file.sql');
  lines.push('-- ======================================\n');
  
  lines.push('BEGIN;');
  
  // Count total tests
  let testCount = 0;
  for (const [, tableConfig] of Object.entries(config.tables)) {
    for (const scenario of tableConfig.test_scenarios) {
      const operations = ['SELECT', 'INSERT', 'UPDATE', 'DELETE'] as DatabaseOperation[];
      for (const op of operations) {
        if (scenario.expected[op] && scenario.expected[op] !== 'ERROR') {
          testCount++;
        }
      }
    }
  }
  
  lines.push(`SELECT plan(${testCount});\n`);

  // Generate tests for each table/scenario/operation
  for (const [tableKey, tableConfig] of Object.entries(config.tables)) {
    const [schema, table] = tableKey.split('.');
    
    lines.push(`-- Tests for ${tableKey}`);
    
    for (const scenario of tableConfig.test_scenarios) {
      lines.push(`-- Scenario: ${scenario.name}`);
      
      const operations = ['SELECT', 'INSERT', 'UPDATE', 'DELETE'] as DatabaseOperation[];
      
      for (const operation of operations) {
        const expected = scenario.expected[operation];
        if (!expected || expected === 'ERROR') continue;

        const testSql = generateOperationTest(
          schema,
          table,
          operation,
          scenario.name,
          expected,
          scenario.jwt_claims
        );
        
        lines.push(testSql);
      }
      
      lines.push('');
    }
  }

  lines.push('SELECT * FROM finish();');
  lines.push('ROLLBACK;');

  return lines.join('\n');
}

function generateOperationTest(
  schema: string,
  table: string,
  operation: DatabaseOperation,
  scenarioName: string,
  expected: 'ALLOW' | 'DENY',
  jwtClaims: Record<string, any>
): string {
  const fullTable = `${schema}.${table}`;
  const testName = `${scenarioName} ${operation}`;
  
  const lines: string[] = [];
  
  // Context setup with proper Supabase auth
  const role = jwtClaims.role || 'anon';
  const userId = jwtClaims.sub || null;
  
  lines.push(`-- ${testName}`);
  lines.push(`SET LOCAL ROLE ${role};`);
  
  // Set auth context for Supabase (using request.jwt.claims pattern)
  if (userId) {
    lines.push(`SET LOCAL request.jwt.claims TO '${JSON.stringify(jwtClaims)}';`);
  }

  let testQuery = '';
  
  switch (operation) {
    case 'SELECT':
      if (expected === 'ALLOW') {
        testQuery = `SELECT ok(
  (SELECT COUNT(*) >= 0 FROM ${fullTable} LIMIT 1) IS NOT NULL,
  '${fullTable}: ${testName} should ALLOW'
);`;
      } else {
        testQuery = `SELECT throws_ok(
  'SELECT * FROM ${fullTable}',
  '42501',
  null,
  '${fullTable}: ${testName} should DENY'
);`;
      }
      break;
      
    case 'INSERT':
      if (expected === 'ALLOW') {
        const preparedName = `insert_${table}_${scenarioName.replace(/[^a-z0-9]/gi, '_')}`;
        testQuery = `-- Test INSERT permission using PREPARE
PREPARE ${preparedName} AS INSERT INTO ${fullTable} DEFAULT VALUES;
SELECT lives_ok(
  '${preparedName}',
  '${fullTable}: ${testName} should ALLOW'
);
DEALLOCATE ${preparedName};
-- NOTE: Customize INSERT columns and values for your schema`;
      } else {
        testQuery = `SELECT throws_ok(
  'INSERT INTO ${fullTable} DEFAULT VALUES',
  '42501',
  null,
  '${fullTable}: ${testName} should DENY'
);`;
      }
      break;
      
    case 'UPDATE':
      if (expected === 'ALLOW') {
        const preparedName = `update_${table}_${scenarioName.replace(/[^a-z0-9]/gi, '_')}`;
        testQuery = `-- Test UPDATE permission using PREPARE
PREPARE ${preparedName} AS UPDATE ${fullTable} SET id = id WHERE false;
SELECT lives_ok(
  '${preparedName}',
  '${fullTable}: ${testName} should ALLOW'
);
DEALLOCATE ${preparedName};
-- NOTE: Customize SET clause and WHERE condition for your schema`;
      } else {
        testQuery = `SELECT throws_ok(
  'UPDATE ${fullTable} SET id = id',
  '42501',
  null,
  '${fullTable}: ${testName} should DENY'
);`;
      }
      break;
      
    case 'DELETE':
      if (expected === 'ALLOW') {
        const preparedName = `delete_${table}_${scenarioName.replace(/[^a-z0-9]/gi, '_')}`;
        testQuery = `-- Test DELETE permission using PREPARE
PREPARE ${preparedName} AS DELETE FROM ${fullTable} WHERE false;
SELECT lives_ok(
  '${preparedName}',
  '${fullTable}: ${testName} should ALLOW'
);
DEALLOCATE ${preparedName};
-- NOTE: Customize WHERE condition for your schema`;
      } else {
        testQuery = `SELECT throws_ok(
  'DELETE FROM ${fullTable}',
  '42501',
  null,
  '${fullTable}: ${testName} should DENY'
);`;
      }
      break;
  }

  lines.push(testQuery);
  lines.push('RESET ROLE;');
  lines.push('');

  return lines.join('\n');
}

